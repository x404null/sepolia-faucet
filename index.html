
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pacman Mini</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: system-ui, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }

  .wrap {
    text-align: center;
  }

  canvas {
    background: #000;
    border: 3px solid #1f2a4f;
  }

  .info {
    margin-top: 10px;
    font-size: 16px;
  }

  .btn {
    margin-top: 10px;
    padding: 10px 18px;
    border-radius: 10px;
    border: none;
    font-weight: bold;
    cursor: pointer;
    background: #ffd700;
    color: #000;
  }
</style>
</head>

<body>

<div class="wrap">
  <canvas id="game" width="360" height="360"></canvas>
  <div class="info">
    üèÅ Level: <span id="level">1</span> |
    üçí Score: <span id="score">0</span>
  </div>
  <button class="btn" onclick="restart()">Restart</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const tile = 20;
const rows = 18;
const cols = 18;

let level = 1;
let score = 0;

const levelEl = document.getElementById("level");
const scoreEl = document.getElementById("score");

let map = [];
let dots = 0;

let pacman;
let ghosts = [];
let speed = 2;

// ===== SIMPLE MAP =====
const baseMap = [
"##################",
"#........##......#",
"#.####.###.###.##.#",
"#.................#",
"#.####.##.##.####.#",
"#......##........#",
"######.####.######.",
"#........##......#",
"#.####.###.###.##.#",
"#.................#",
"#.####.##.##.####.#",
"#......##........#",
"##################"
];

function loadMap() {
  map = baseMap.map(row => row.split(""));
  dots = 0;

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      if (map[y][x] === ".") dots++;
    }
  }
}

// ===== ENTITIES =====
function resetEntities() {
  pacman = {
    x: 1 * tile,
    y: 1 * tile,
    dx: speed,
    dy: 0,
    size: tile / 2
  };

  ghosts = [];
  for (let i = 0; i < level; i++) {
    ghosts.push({
      x: 9 * tile,
      y: 6 * tile,
      dx: Math.random() > 0.5 ? speed : -speed,
      dy: Math.random() > 0.5 ? speed : -speed
    });
  }
}

// ===== CONTROLS =====
document.addEventListener("keydown", e => {
  if (e.key === "ArrowUp")    { pacman.dx = 0; pacman.dy = -speed; }
  if (e.key === "ArrowDown")  { pacman.dx = 0; pacman.dy = speed; }
  if (e.key === "ArrowLeft")  { pacman.dx = -speed; pacman.dy = 0; }
  if (e.key === "ArrowRight") { pacman.dx = speed; pacman.dy = 0; }
});

// ===== GAME LOOP =====
function update() {
  movePacman();
  moveGhosts();
  checkCollisions();
  draw();
  requestAnimationFrame(update);
}

function movePacman() {
  const nx = pacman.x + pacman.dx;
  const ny = pacman.y + pacman.dy;

  const col = Math.floor(nx / tile);
  const row = Math.floor(ny / tile);

  if (map[row] && map[row][col] !== "#") {
    pacman.x = nx;
    pacman.y = ny;
  }

  // eat dot
  if (map[row] && map[row][col] === ".") {
    map[row][col] = " ";
    score += 10;
    dots--;
    scoreEl.innerText = score;

    if (dots === 0) nextLevel();
  }
}

function moveGhosts() {
  ghosts.forEach(g => {
    const nx = g.x + g.dx;
    const ny = g.y + g.dy;

    const col = Math.floor(nx / tile);
    const row = Math.floor(ny / tile);

    if (map[row] && map[row][col] !== "#") {
      g.x = nx;
      g.y = ny;
    } else {
      g.dx = (Math.random() > 0.5 ? 1 : -1) * speed;
      g.dy = (Math.random() > 0.5 ? 1 : -1) * speed;
    }
  });
}

function checkCollisions() {
  ghosts.forEach(g => {
    const dx = g.x - pacman.x;
    const dy = g.y - pacman.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < tile / 2) {
      alert("üíÄ Game Over!");
      restart();
    }
  });
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // map
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      if (map[y][x] === "#") {
        ctx.fillStyle = "#1f2a4f";
        ctx.fillRect(x * tile, y * tile, tile, tile);
      }
      if (map[y][x] === ".") {
        ctx.fillStyle = "#ffd700";
        ctx.beginPath();
        ctx.arc(x * tile + tile/2, y * tile + tile/2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // pacman
  ctx.fillStyle = "yellow";
  ctx.beginPath();
  ctx.arc(pacman.x + tile/2, pacman.y + tile/2, pacman.size, 0.25 * Math.PI, 1.75 * Math.PI);
  ctx.lineTo(pacman.x + tile/2, pacman.y + tile/2);
  ctx.fill();

  // ghosts
  ghosts.forEach(g => {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(g.x + tile/2, g.y + tile/2, tile/2, 0, Math.PI * 2);
    ctx.fill();
  });
}

// ===== LEVEL =====
function nextLevel() {
  level++;
  speed += 0.5;
  levelEl.innerText = level;
  loadMap();
  resetEntities();
}

function restart() {
  level = 1;
  speed = 2;
  score = 0;
  levelEl.innerText = level;
  scoreEl.innerText = score;
  loadMap();
  resetEntities();
}

// INIT
loadMap();
resetEntities();
update();
</script>

</body>
</html>
